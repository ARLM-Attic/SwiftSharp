<article class="chapter">
  <a name="//apple_ref/doc/uid/TP40014097-CH7"></a><a name="//apple_ref/doc/uid/TP40014097-CH7-XID_418"></a>
  <div class="pixel-line"></div>
  <h2 class="chapter-name chapter-name-short">Strings and Characters</h2>


      <section id="mini_toc" class="hideInXcode slide-out" role="navigation">
	<div id="mini_toc_button">
  	<p>On This Page</p>
  </div>
  <ul class="list-bullet">
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_420">
	  				String Literals
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_422">
	  				Initializing an Empty String
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_423">
	  				String Mutability
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_425">
	  				Strings Are Value Types
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_427">
	  				Working with Characters
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_428">
	  				Concatenating Strings and Characters
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_430">
	  				String Interpolation
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_432">
	  				Unicode
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_437">
	  				Counting Characters
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_439">
	  				Comparing Strings
	  			</a>
  			</p>
  		</li>
  		<li class="item">
  			<p class="para">
	  			<a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_444">
	  				Unicode Representations of Strings
	  			</a>
  			</p>
  		</li>
	</ul>
</section>

  
  	<section class="section">
  		<p class="para">
  A <em>string</em> is an ordered collection of characters, such as <code class="code-voice">"hello, world"</code> or <code class="code-voice">"albatross"</code>. Swift strings are represented by the <code class="code-voice">String</code> type, which in turn represents a collection of values of <code class="code-voice">Character</code> type.
</p>
<p class="para">
  Swift’s <code class="code-voice">String</code> and <code class="code-voice">Character</code> types provide a fast, Unicode-compliant way to work with text in your code. The syntax for string creation and manipulation is lightweight and readable, with a string literal syntax that is similar to C. String concatenation is as simple as adding together two strings with the <code class="code-voice">+</code> operator, and string mutability is managed by choosing between a constant or a variable, just like any other value in Swift.
</p>
<p class="para">
  Despite this simplicity of syntax, Swift’s <code class="code-voice">String</code> type is a fast, modern string implementation. Every string is composed of encoding-independent Unicode characters, and provides support for accessing those characters in various Unicode representations.
</p>
<p class="para">
  Strings can also be used to insert constants, variables, literals, and expressions into longer strings, in a process known as string interpolation. This makes it easy to create custom string values for display, storage, and printing.
</p>
<div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_419"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">Swift’s <code class="code-voice">String</code> type is bridged seamlessly to Foundation’s <code class="code-voice">NSString</code> class. If you are working with the Foundation framework in Cocoa or Cocoa Touch, the entire <code class="code-voice">NSString</code> API is available to call on any <code class="code-voice">String</code> value you create, in addition to the <code class="code-voice">String</code> features described in this chapter. You can also use a <code class="code-voice">String</code> value with any API that requires an <code class="code-voice">NSString</code> instance.
    	</p>
    <p class="para">
  For more information about using <code class="code-voice">String</code> with Foundation and Cocoa, see <em class="u-book"><a href="../BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_self">Using Swift with Cocoa and Objective-C</a></em>.
</p>

  </aside>
</div>

		</section> 


  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_420"></a>
  <h3 class="section-name" tabindex="0">String Literals</h3>
  <p class="para">
  You can include predefined <code class="code-voice">String</code> values within your code as <em>string literals</em>. A string literal is a fixed sequence of textual characters surrounded by a pair of double quotes (<code class="code-voice">""</code>).
</p><p class="para">
  A string literal can be used to provide an initial value for a constant or variable:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">someString</span> = <span class="s">"Some string literal value"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Note that Swift infers a type of <code class="code-voice">String</code> for the <code class="code-voice">someString</code> constant, because it is initialized with a string literal value.
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_421"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">For information about using special characters in string literals, see <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_435" data-id="//apple_ref/doc/uid/TP40014097-CH7-XID_435">Special Unicode Characters in String Literals</a></span>.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_422"></a>
  <h3 class="section-name" tabindex="0">Initializing an Empty String</h3>
  <p class="para">
  To create an empty <code class="code-voice">String</code> value as the starting point for building a longer string, either assign an empty string literal to a variable, or initialize a new <code class="code-voice">String</code> instance with initializer syntax:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">emptyString</span> = <span class="s">""</span>               <span class="c">// empty string literal</span></code></li>
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">anotherEmptyString</span> = <span class="vc">String</span>()  <span class="c">// initializer syntax</span></code></li>
          <li><code class="code-voice"><span class="c">// these two strings are both empty, and are equivalent to each other</span></code></li>
      </ul>



  </div>
</section><p class="para">
  You can find out whether a <code class="code-voice">String</code> value is empty by checking its Boolean <code class="code-voice">isEmpty</code> property:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">if</span> <span class="vc">emptyString</span>.<span class="vc">isEmpty</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="s">"Nothing to see here"</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// prints "Nothing to see here"</span></code></li>
      </ul>



  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_423"></a>
  <h3 class="section-name" tabindex="0">String Mutability</h3>
  <p class="para">
  You indicate whether a particular <code class="code-voice">String</code> can be modified (or <em>mutated</em>) by assigning it to a variable (in which case it can be modified), or to a constant (in which case it cannot be modified):
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">variableString</span> = <span class="s">"Horse"</span></code></li>
          <li><code class="code-voice"><span class="vc">variableString</span> += <span class="s">" and carriage"</span></code></li>
          <li><code class="code-voice"><span class="c">// variableString is now "Horse and carriage"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">constantString</span> = <span class="s">"Highlander"</span></code></li>
          <li><code class="code-voice"><span class="vc">constantString</span> += <span class="s">" and another Highlander"</span></code></li>
          <li><code class="code-voice"><span class="c">// this reports a compile-time error - a constant string cannot be modified</span></code></li>
      </ul>



  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_424"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">This approach is different from string mutation in Objective-C and Cocoa, where you choose between two classes (<code class="code-voice">NSString</code> and <code class="code-voice">NSMutableString</code>) to indicate whether a string can be mutated.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_425"></a>
  <h3 class="section-name" tabindex="0">Strings Are Value Types</h3>
  <p class="para">
  Swift’s <code class="code-voice">String</code> type is a <em>value type</em>. If you create a new <code class="code-voice">String</code> value, that <code class="code-voice">String</code> value is <em>copied</em> when it is passed to a function or method, or when it is assigned to a constant or variable. In each case, a new copy of the existing <code class="code-voice">String</code> value is created, and the new copy is passed or assigned, not the original version. Value types are described in <span class="x-name"><a href="ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-XID_145" data-id="//apple_ref/doc/uid/TP40014097-CH13-XID_145">Structures and Enumerations Are Value Types</a></span>.
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_426"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">This behavior differs from that of <code class="code-voice">NSString</code> in Cocoa. When you create an <code class="code-voice">NSString</code> instance in Cocoa, and pass it to a function or method or assign it to a variable, you are always passing or assigning a <em>reference</em> to the same single <code class="code-voice">NSString</code>. No copying of the string takes place, unless you specifically request it.
    	</p>
    
  </aside>
</div><p class="para">
  Swift’s copy-by-default <code class="code-voice">String</code> behavior ensures that when a function or method passes you a <code class="code-voice">String</code> value, it is clear that you own that exact <code class="code-voice">String</code> value, regardless of where it came from. You can be confident that the string you are passed will not be modified unless you modify it yourself.
</p><p class="para">
  Behind the scenes, Swift’s compiler optimizes string usage so that actual copying takes place only when absolutely necessary. This means you always get great performance when working with strings as value types.
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_427"></a>
  <h3 class="section-name" tabindex="0">Working with Characters</h3>
  <p class="para">
  Swift’s <code class="code-voice">String</code> type represents a collection of <code class="code-voice">Character</code> values in a specified order. You can access the individual <code class="code-voice">Character</code> values in a string by iterating over that string with a <code class="code-voice">for</code>-<code class="code-voice">in</code> loop:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">character</span> <span class="kt">in</span> <span class="s">"Dog!🐶"</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="vc">character</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// D</span></code></li>
          <li><code class="code-voice"><span class="c">// o</span></code></li>
          <li><code class="code-voice"><span class="c">// g</span></code></li>
          <li><code class="code-voice"><span class="c">// !</span></code></li>
          <li><code class="code-voice"><span class="c">// 🐶</span></code></li>
      </ul>



  </div>
</section><p class="para">
  The <code class="code-voice">for</code>-<code class="code-voice">in</code> loop is described in <span class="x-name"><a href="ControlFlow.html#//apple_ref/doc/uid/TP40014097-CH9-XID_192" data-id="//apple_ref/doc/uid/TP40014097-CH9-XID_192">For Loops</a></span>.
</p><p class="para">
  Alternatively, create a stand-alone <code class="code-voice">Character</code> constant or variable from a single-character string literal by providing a <code class="code-voice">Character</code> type annotation:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">yenSign</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"¥"</span></code></li>
      </ul>



  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_428"></a>
  <h3 class="section-name" tabindex="0">Concatenating Strings and Characters</h3>
  <p class="para">
  <code class="code-voice">String</code> values can be added together (or <em>concatenated</em>) with the addition operator (<code class="code-voice">+</code>) to create a new <code class="code-voice">String</code> value:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">string1</span> = <span class="s">"hello"</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">string2</span> = <span class="s">" there"</span></code></li>
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">welcome</span> = <span class="vc">string1</span> + <span class="vc">string2</span></code></li>
          <li><code class="code-voice"><span class="c">// welcome now equals "hello there"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  You can also append a <code class="code-voice">String</code> value to an existing <code class="code-voice">String</code> variable with the addition assignment operator (<code class="code-voice">+=</code>):
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">instruction</span> = <span class="s">"look over"</span></code></li>
          <li><code class="code-voice"><span class="vc">instruction</span> += <span class="vc">string2</span></code></li>
          <li><code class="code-voice"><span class="c">// instruction now equals "look over there"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  You can append a <code class="code-voice">Character</code> value to a <code class="code-voice">String</code> variable with the <code class="code-voice">String</code> type’s <code class="code-voice">append</code> method:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">exclamationMark</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"!"</span></code></li>
          <li><code class="code-voice"><span class="vc">welcome</span>.<span class="vc">append</span>(<span class="vc">exclamationMark</span>)</code></li>
          <li><code class="code-voice"><span class="c">// welcome now equals "hello there!"</span></code></li>
      </ul>



  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_429"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">You can’t append a <code class="code-voice">String</code> or <code class="code-voice">Character</code> to an existing <code class="code-voice">Character</code> variable, because a <code class="code-voice">Character</code> value must contain a single character only.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_430"></a>
  <h3 class="section-name" tabindex="0">String Interpolation</h3>
  <p class="para">
  <em>String interpolation</em> is a way to construct a new <code class="code-voice">String</code> value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. Each item that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">multiplier</span> = <span class="m">3</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">message</span> = <span class="s">"</span>\(<span class="vc">multiplier</span>)<span class="s"> times 2.5 is </span>\(<span class="vc">Double</span>(<span class="vc">multiplier</span>) * <span class="m">2.5</span>)<span class="s">"</span></code></li>
          <li><code class="code-voice"><span class="c">// message is "3 times 2.5 is 7.5"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  In the example above, the value of <code class="code-voice">multiplier</code> is inserted into a string literal as <code class="code-voice">\(multiplier)</code>. This placeholder is replaced with the actual value of <code class="code-voice">multiplier</code> when the string interpolation is evaluated to create an actual string.
</p><p class="para">
  The value of <code class="code-voice">multiplier</code> is also part of a larger expression later in the string. This expression calculates the value of <code class="code-voice">Double(multiplier) * 2.5</code> and inserts the result (<code class="code-voice">7.5</code>) into the string. In this case, the expression is written as <code class="code-voice">\(Double(multiplier) * 2.5)</code> when it is included inside the string literal.
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_431"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">The expressions you write inside parentheses within an interpolated string cannot contain an unescaped double quote (<code class="code-voice">"</code>) or backslash (<code class="code-voice">\</code>), and cannot contain a carriage return or line feed.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_432"></a>
  <h3 class="section-name" tabindex="0">Unicode</h3>
  <p class="para">
  <em>Unicode</em> is an international standard for encoding, representing, and processing text in different writing systems. It enables you to represent almost any character from any language in a standardized form, and to read and write those characters to and from an external source such as a text file or web page. Swift’s <code class="code-voice">String</code> and <code class="code-voice">Character</code> types are fully Unicode-compliant, as described in this section.
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_433"></a>
  <h3 class="section-name" tabindex="0">Unicode Scalars</h3>
  <p class="para">
  Behind the scenes, Swift’s native <code class="code-voice">String</code> type is built from <em>Unicode scalar</em> values. A Unicode scalar is a unique 21-bit number for a character or modifier, such as <code class="code-voice">U+0061</code> for <code class="code-voice">LATIN SMALL LETTER A</code> (<code class="code-voice">"a"</code>), or <code class="code-voice">U+1F425</code> for <code class="code-voice">FRONT-FACING BABY CHICK</code> (<code class="code-voice">"🐥"</code>).
</p><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_434"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">A Unicode scalar is any Unicode <em>code point</em> in the range <code class="code-voice">U+0000</code> to <code class="code-voice">U+D7FF</code> inclusive or <code class="code-voice">U+E000</code> to <code class="code-voice">U+10FFFF</code> inclusive. Unicode scalars do not include the Unicode <em>surrogate pair</em> code points in the range <code class="code-voice">U+D800</code> to <code class="code-voice">U+DFFF</code> inclusive.
    	</p>
    
  </aside>
</div><p class="para">
  Note that not all 21-bit Unicode scalars are assigned to a character—some scalars are reserved for future assignment. Scalars that have been assigned to a character typically also have a name, such as <code class="code-voice">LATIN SMALL LETTER A</code> and <code class="code-voice">FRONT-FACING BABY CHICK</code> in the examples above.
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_435"></a>
  <h3 class="section-name" tabindex="0">Special Unicode Characters in String Literals</h3>
  <p class="para">
  String literals can include the following special Unicode characters:
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  The escaped special characters <code class="code-voice">\0</code> (null character), <code class="code-voice">\\</code> (backslash), <code class="code-voice">\t</code> (horizontal tab), <code class="code-voice">\n</code> (line feed), <code class="code-voice">\r</code> (carriage return), <code class="code-voice">\"</code> (double quote) and <code class="code-voice">\'</code> (single quote)
</p>
</li><li class="item"><p class="para">
  An arbitrary Unicode scalar, written as <code class="code-voice">\u{</code><em>n</em><code class="code-voice">}</code>, where <em>n</em> is between one and eight hexadecimal digits
</p>
</li>
</ul><p class="para">
  The code below shows four examples of these special characters. The <code class="code-voice">wiseWords</code> constant contains two escaped double quote characters. The <code class="code-voice">dollarSign</code>, <code class="code-voice">blackHeart</code>, and <code class="code-voice">sparklingHeart</code> constants demonstrate the Unicode scalar format:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">wiseWords</span> = <span class="s">"\"Imagination is more important than knowledge\" - Einstein"</span></code></li>
          <li><code class="code-voice"><span class="c">// "Imagination is more important than knowledge" - Einstein</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">dollarSign</span> = <span class="s">"\u{24}"</span>        <span class="c">// $,  Unicode scalar U+0024</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">blackHeart</span> = <span class="s">"\u{2665}"</span>      <span class="c">// ♥,  Unicode scalar U+2665</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">sparklingHeart</span> = <span class="s">"\u{1F496}"</span> <span class="c">// 💖, Unicode scalar U+1F496</span></code></li>
      </ul>



  </div>
</section>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_436"></a>
  <h3 class="section-name" tabindex="0">Extended Grapheme Clusters</h3>
  <p class="para">
  Every instance of Swift’s <code class="code-voice">Character</code> type represents a single <em>extended grapheme cluster</em>. An extended grapheme cluster is a sequence of one or more Unicode scalars that (when combined) produce a single human-readable character.
</p><p class="para">
  Here’s an example. The letter <code class="code-voice">é</code> can be represented as the single Unicode scalar <code class="code-voice">é</code> (<code class="code-voice">LATIN SMALL LETTER E WITH ACUTE</code>, or <code class="code-voice">U+00E9</code>). However, the same letter can also be represented as a <em>pair</em> of scalars—a standard letter <code class="code-voice">e</code> (<code class="code-voice">LATIN SMALL LETTER E</code>, or <code class="code-voice">U+0065</code>), followed by the <code class="code-voice">COMBINING ACUTE ACCENT</code> scalar (<code class="code-voice">U+0301</code>). The <code class="code-voice">COMBINING ACUTE ACCENT</code> scalar is graphically applied to the scalar that precedes it, turning an <code class="code-voice">e</code> into an <code class="code-voice">é</code> when it is rendered by a Unicode-aware text-rendering system.
</p><p class="para">
  In both cases, the letter <code class="code-voice">é</code> is represented as a single Swift <code class="code-voice">Character</code> value that represents an extended grapheme cluster. In the first case, the cluster contains a single scalar; in the second case, it is a cluster of two scalars:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">eAcute</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{E9}"</span>                         <span class="c">// é</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">combinedEAcute</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{65}\u{301}"</span>          <span class="c">// e followed by ́</span></code></li>
          <li><code class="code-voice"><span class="c">// eAcute is é, combinedEAcute is é</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Extended grapheme clusters are a flexible way to represent many complex script characters as a single <code class="code-voice">Character</code> value. For example, Hangul syllables from the Korean alphabet can be represented as either a precomposed or decomposed sequence. Both of these representations qualify as a single <code class="code-voice">Character</code> value in Swift:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">precomposed</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{D55C}"</span>                  <span class="c">// 한</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">decomposed</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{1112}\u{1161}\u{11AB}"</span>   <span class="c">// ᄒ, ᅡ, ᆫ</span></code></li>
          <li><code class="code-voice"><span class="c">// precomposed is 한, decomposed is 한</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Extended grapheme clusters enable scalars for enclosing marks (such as <code class="code-voice">COMBINING ENCLOSING CIRCLE</code>, or <code class="code-voice">U+20DD</code>) to enclose other Unicode scalars as part of a single <code class="code-voice">Character</code> value:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">enclosedEAcute</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{E9}\u{20DD}"</span></code></li>
          <li><code class="code-voice"><span class="c">// enclosedEAcute is é⃝</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Unicode scalars for regional indicator symbols can be combined in pairs to make a single <code class="code-voice">Character</code> value, such as this combination of <code class="code-voice">REGIONAL INDICATOR SYMBOL LETTER U</code> (<code class="code-voice">U+1F1FA</code>) and <code class="code-voice">REGIONAL INDICATOR SYMBOL LETTER S</code> (<code class="code-voice">U+1F1F8</code>):
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">regionalIndicatorForUS</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{1F1FA}\u{1F1F8}"</span></code></li>
          <li><code class="code-voice"><span class="c">// regionalIndicatorForUS is 🇺🇸</span></code></li>
      </ul>



  </div>
</section>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_437"></a>
  <h3 class="section-name" tabindex="0">Counting Characters</h3>
  <p class="para">
  To retrieve a count of the <code class="code-voice">Character</code> values in a string, call the global <code class="code-voice">countElements</code> function and pass in a string as the function’s sole parameter:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">unusualMenagerie</span> = <span class="s">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></code></li>
          <li><code class="code-voice"><span class="vc">println</span>(<span class="s">"unusualMenagerie has </span>\(<span class="vc">countElements</span>(<span class="vc">unusualMenagerie</span>))<span class="s"> characters"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// prints "unusualMenagerie has 40 characters"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Note that Swift’s use of extended grapheme clusters for <code class="code-voice">Character</code> values means that string concatenation and modification may not always affect a string’s character count.
</p><p class="para">
  For example, if you initialize a new string with the four-character word <code class="code-voice">cafe</code>, and then append a <code class="code-voice">COMBINING ACUTE ACCENT</code> (<code class="code-voice">U+0301</code>) to the end of the string, the resulting string will still have a character count of <code class="code-voice">4</code>, with a fourth character of <code class="code-voice">é</code>, not <code class="code-voice">e</code>:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">word</span> = <span class="s">"cafe"</span></code></li>
          <li><code class="code-voice"><span class="vc">println</span>(<span class="s">"the number of characters in </span>\(<span class="vc">word</span>)<span class="s"> is </span>\(<span class="vc">countElements</span>(<span class="vc">word</span>))<span class="s">"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// prints "the number of characters in cafe is 4"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="vc">word</span> += <span class="s">"\u{301}"</span>    <span class="c">// COMBINING ACUTE ACCENT, U+0301</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="vc">println</span>(<span class="s">"the number of characters in </span>\(<span class="vc">word</span>)<span class="s"> is </span>\(<span class="vc">countElements</span>(<span class="vc">word</span>))<span class="s">"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// prints "the number of characters in café is 4"</span></code></li>
      </ul>



  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_438"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">Extended grapheme clusters can be composed of one or more Unicode scalars. This means that different characters, and different representations of the same character, can require different amounts of memory to store. Because of this, characters in Swift do not each take up the same amount of memory within a string’s representation. As a result, the number of characters in a string cannot be calculated without iterating through the string to determine its extended grapheme cluster boundaries. If you are working with particularly long string values, be aware that the <code class="code-voice">countElements</code> function must iterate over the Unicode scalars in the entire string in order to calculate an accurate character count for that string.
    	</p>
    <p class="para">
  Note also that the character count returned by <code class="code-voice">countElements</code> is not always the same as the <code class="code-voice">length</code> property of an <code class="code-voice">NSString</code> that contains the same characters. The length of an <code class="code-voice">NSString</code> is based on the number of 16-bit code units within the string’s UTF-16 representation and not the number of Unicode extended grapheme clusters within the string. To reflect this fact, the <code class="code-voice">length</code> property from <code class="code-voice">NSString</code> is called <code class="code-voice">utf16Count</code> when it is accessed on a Swift <code class="code-voice">String</code> value.
</p>

  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_439"></a>
  <h3 class="section-name" tabindex="0">Comparing Strings</h3>
  <p class="para">
  Swift provides three ways to compare textual values: string and character equality, prefix equality, and suffix equality.
</p>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_440"></a>
  <h3 class="section-name" tabindex="0">String and Character Equality</h3>
  <p class="para">
  String and character equality is checked with the “equal to” operator (<code class="code-voice">==</code>) and the “not equal to” operator (<code class="code-voice">!=</code>), as described in <span class="x-name"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_121" data-id="//apple_ref/doc/uid/TP40014097-CH6-XID_121">Comparison Operators</a></span>:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">quotation</span> = <span class="s">"We're a lot alike, you and I."</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">sameQuotation</span> = <span class="s">"We're a lot alike, you and I."</span></code></li>
          <li><code class="code-voice"><span class="kt">if</span> <span class="vc">quotation</span> == <span class="vc">sameQuotation</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="s">"These two strings are considered equal"</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// prints "These two strings are considered equal"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Two <code class="code-voice">String</code> values (or two <code class="code-voice">Character</code> values) are considered equal if their extended grapheme clusters are <em>canonically equivalent</em>. Extended grapheme clusters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.
</p><p class="para">
  For example, <code class="code-voice">LATIN SMALL LETTER E WITH ACUTE</code> (<code class="code-voice">U+00E9</code>) is canonically equivalent to <code class="code-voice">LATIN SMALL LETTER E</code> (<code class="code-voice">U+0065</code>) followed by <code class="code-voice">COMBINING ACUTE ACCENT</code> (<code class="code-voice">U+0301</code>). Both of these extended grapheme clusters are valid ways to represent the character <code class="code-voice">é</code>, and so they are considered to be canonically equivalent:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="c">// "Voulez-vous un café?" using LATIN SMALL LETTER E WITH ACUTE</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">eAcuteQuestion</span> = <span class="s">"Voulez-vous un caf\u{E9}?"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="c">// "Voulez-vous un café?" using LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span></code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">combinedEAcuteQuestion</span> = <span class="s">"Voulez-vous un caf\u{65}\u{301}?"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="kt">if</span> <span class="vc">eAcuteQuestion</span> == <span class="vc">combinedEAcuteQuestion</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="s">"These two strings are considered equal"</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// prints "These two strings are considered equal"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Conversely, <code class="code-voice">LATIN CAPITAL LETTER A</code> (<code class="code-voice">U+0041</code>, or <code class="code-voice">"A"</code>), as used in English, is <em>not</em> equivalent to <code class="code-voice">CYRILLIC CAPITAL LETTER A</code> (<code class="code-voice">U+0410</code>, or <code class="code-voice">"А"</code>), as used in Russian. The characters are visually similar, but do not have the same linguistic meaning:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">latinCapitalLetterA</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{41}"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">cyrillicCapitalLetterA</span>: <span class="n"><!-- a href="" -->Character<!-- /a --></span> = <span class="s">"\u{0410}"</span></code></li>
          <li><code class="code-voice"> </code></li>
          <li><code class="code-voice"><span class="kt">if</span> <span class="vc">latinCapitalLetterA</span> != <span class="vc">cyrillicCapitalLetterA</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="s">"These two characters are not equivalent"</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// prints "These two characters are not equivalent"</span></code></li>
      </ul>



  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_441"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">String and character comparisons in Swift are not locale-sensitive.
    	</p>
    
  </aside>
</div>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_442"></a>
  <h3 class="section-name" tabindex="0">Prefix and Suffix Equality</h3>
  <p class="para">
  To check whether a string has a particular string prefix or suffix, call the string’s <code class="code-voice">hasPrefix</code> and <code class="code-voice">hasSuffix</code> methods, both of which take a single argument of type <code class="code-voice">String</code> and return a Boolean value.
</p><p class="para">
  The examples below consider an array of strings representing the scene locations from the first two acts of Shakespeare’s <em>Romeo and Juliet</em>:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">romeoAndJuliet</span> = [</code></li>
          <li><code class="code-voice">    <span class="s">"Act 1 Scene 1: Verona, A public place"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 1 Scene 2: Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 1 Scene 3: A room in Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 1 Scene 4: A street outside Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 1 Scene 5: The Great Hall in Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 1: Outside Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 2: Capulet's orchard"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 3: Outside Friar Lawrence's cell"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 4: A street in Verona"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 5: Capulet's mansion"</span>,</code></li>
          <li><code class="code-voice">    <span class="s">"Act 2 Scene 6: Friar Lawrence's cell"</span></code></li>
          <li><code class="code-voice">]</code></li>
      </ul>



  </div>
</section><p class="para">
  You can use the <code class="code-voice">hasPrefix</code> method with the <code class="code-voice">romeoAndJuliet</code> array to count the number of scenes in Act 1 of the play:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">act1SceneCount</span> = <span class="m">0</span></code></li>
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">scene</span> <span class="kt">in</span> <span class="vc">romeoAndJuliet</span> {</code></li>
          <li><code class="code-voice">    <span class="kt">if</span> <span class="vc">scene</span>.<span class="vc">hasPrefix</span>(<span class="s">"Act 1 "</span>) {</code></li>
          <li><code class="code-voice">        ++<span class="vc">act1SceneCount</span></code></li>
          <li><code class="code-voice">    }</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="vc">println</span>(<span class="s">"There are </span>\(<span class="vc">act1SceneCount</span>)<span class="s"> scenes in Act 1"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// prints "There are 5 scenes in Act 1"</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Similarly, use the <code class="code-voice">hasSuffix</code> method to count the number of scenes that take place in or around Capulet’s mansion and Friar Lawrence’s cell:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">mansionCount</span> = <span class="m">0</span></code></li>
          <li><code class="code-voice"><span class="kt">var</span> <span class="vc">cellCount</span> = <span class="m">0</span></code></li>
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">scene</span> <span class="kt">in</span> <span class="vc">romeoAndJuliet</span> {</code></li>
          <li><code class="code-voice">    <span class="kt">if</span> <span class="vc">scene</span>.<span class="vc">hasSuffix</span>(<span class="s">"Capulet's mansion"</span>) {</code></li>
          <li><code class="code-voice">        ++<span class="vc">mansionCount</span></code></li>
          <li><code class="code-voice">    } <span class="kt">else</span> <span class="kt">if</span> <span class="vc">scene</span>.<span class="vc">hasSuffix</span>(<span class="s">"Friar Lawrence's cell"</span>) {</code></li>
          <li><code class="code-voice">        ++<span class="vc">cellCount</span></code></li>
          <li><code class="code-voice">    }</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="vc">println</span>(<span class="s">"</span>\(<span class="vc">mansionCount</span>)<span class="s"> mansion scenes; </span>\(<span class="vc">cellCount</span>)<span class="s"> cell scenes"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// prints "6 mansion scenes; 2 cell scenes"</span></code></li>
      </ul>



  </div>
</section><div class="note">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_443"></a>
  <aside class="aside">
    <p class="aside-title">Note
    </p>
    	<p class="para">The <code class="code-voice">hasPrefix</code> and <code class="code-voice">hasSuffix</code> methods perform a character-by-character canonical equivalence comparison between the extended grapheme clusters in each string, as described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_440" data-id="//apple_ref/doc/uid/TP40014097-CH7-XID_440">String and Character Equality</a></span>.
    	</p>
    
  </aside>
</div>
  
</section>

</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_444"></a>
  <h3 class="section-name" tabindex="0">Unicode Representations of Strings</h3>
  <p class="para">
  When a Unicode string is written to a text file or some other storage, the Unicode scalars in that string are encoded in one of several Unicode-defined <em>encoding forms</em>. Each form encodes the string in small chunks known as <em>code units</em>. These include the UTF-8 encoding form (which encodes a string as 8-bit code units), the UTF-16 encoding form (which encodes a string as 16-bit code units), and the UTF-32 encoding form (which encodes a string as 32-bit code units).
</p><p class="para">
  Swift provides several different ways to access Unicode representations of strings. You can iterate over the string with a <code class="code-voice">for</code>-<code class="code-voice">in</code> statement, to access its individual <code class="code-voice">Character</code> values as Unicode extended grapheme clusters. This process is described in <span class="x-name"><a href="#//apple_ref/doc/uid/TP40014097-CH7-XID_427" data-id="//apple_ref/doc/uid/TP40014097-CH7-XID_427">Working with Characters</a></span>.
</p><p class="para">
  Alternatively, access a <code class="code-voice">String</code> value in one of three other Unicode-compliant representations:
</p><ul class="list-bullet">
  <li class="item"><p class="para">
  A collection of UTF-8 code units (accessed with the string’s <code class="code-voice">utf8</code> property)
</p>
</li><li class="item"><p class="para">
  A collection of UTF-16 code units (accessed with the string’s <code class="code-voice">utf16</code> property)
</p>
</li><li class="item"><p class="para">
  A collection of 21-bit Unicode scalar values, equivalent to the string’s UTF-32 encoding form (accessed with the string’s <code class="code-voice">unicodeScalars</code> property)
</p>
</li>
</ul><p class="para">
  Each example below shows a different representation of the following string, which is made up of the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, <code class="code-voice">g</code>, <code class="code-voice">‼</code> (<code class="code-voice">DOUBLE EXCLAMATION MARK</code>, or Unicode scalar <code class="code-voice">U+203C</code>), and the 🐶 character (<code class="code-voice">DOG FACE</code>, or Unicode scalar <code class="code-voice">U+1F436</code>):
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">let</span> <span class="vc">dogString</span> = <span class="s">"Dog‼🐶"</span></code></li>
      </ul>



  </div>
</section>
  <section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_445"></a>
  <h3 class="section-name" tabindex="0">UTF-8 Representation</h3>
  <p class="para">
  You can access a UTF-8 representation of a <code class="code-voice">String</code> by iterating over its <code class="code-voice">utf8</code> property. This property is of type <code class="code-voice">String.UTF8View</code>, which is a collection of unsigned 8-bit (<code class="code-voice">UInt8</code>) values, one for each byte in the string’s UTF-8 representation:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">codeUnit</span> <span class="kt">in</span> <span class="vc">dogString</span>.<span class="vc">utf8</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">"</span>\(<span class="vc">codeUnit</span>)<span class="s"> "</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="vc">print</span>(<span class="s">"\n"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// 68 111 103 226 128 188 240 159 144 182</span></code></li>
      </ul>



  </div>
</section><p class="para">
  In the example above, the first three decimal <code class="code-voice">codeUnit</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>, whose UTF-8 representation is the same as their ASCII representation. The next three decimal <code class="code-voice">codeUnit</code> values (<code class="code-voice">226</code>, <code class="code-voice">128</code>, <code class="code-voice">188</code>) are a three-byte UTF-8 representation of the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character. The last four <code class="code-voice">codeUnit</code> values (<code class="code-voice">240</code>, <code class="code-voice">159</code>, <code class="code-voice">144</code>, <code class="code-voice">182</code>) are a four-byte UTF-8 representation of the <code class="code-voice">DOG FACE</code> character.
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_446"></a>
  <h3 class="section-name" tabindex="0">UTF-16 Representation</h3>
  <p class="para">
  You can access a UTF-16 representation of a <code class="code-voice">String</code> by iterating over its <code class="code-voice">utf16</code> property. This property is of type <code class="code-voice">String.UTF16View</code>, which is a collection of unsigned 16-bit (<code class="code-voice">UInt16</code>) values, one for each 16-bit code unit in the string’s UTF-16 representation:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">codeUnit</span> <span class="kt">in</span> <span class="vc">dogString</span>.<span class="vc">utf16</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">"</span>\(<span class="vc">codeUnit</span>)<span class="s"> "</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="vc">print</span>(<span class="s">"\n"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// 68 111 103 8252 55357 56374</span></code></li>
      </ul>



  </div>
</section><p class="para">
  Again, the first three <code class="code-voice">codeUnit</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>, whose UTF-16 code units have the same values as in the string’s UTF-8 representation (because these Unicode scalars represent ASCII characters).
</p><p class="para">
  The fourth <code class="code-voice">codeUnit</code> value (<code class="code-voice">8252</code>) is a decimal equivalent of the hexadecimal value <code class="code-voice">203C</code>, which represents the Unicode scalar <code class="code-voice">U+203C</code> for the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character. This character can be represented as a single code unit in UTF-16.
</p><p class="para">
  The fifth and sixth <code class="code-voice">codeUnit</code> values (<code class="code-voice">55357</code> and <code class="code-voice">56374</code>) are a UTF-16 surrogate pair representation of the <code class="code-voice">DOG FACE</code> character. These values are a high-surrogate value of <code class="code-voice">U+D83D</code> (decimal value <code class="code-voice">55357</code>) and a low-surrogate value of <code class="code-voice">U+DC36</code> (decimal value <code class="code-voice">56374</code>).
</p>
  
</section>
<section class="section">
  <a name="//apple_ref/doc/uid/TP40014097-CH7-XID_447"></a>
  <h3 class="section-name" tabindex="0">Unicode Scalar Representation</h3>
  <p class="para">
  You can access a Unicode scalar representation of a <code class="code-voice">String</code> value by iterating over its <code class="code-voice">unicodeScalars</code> property. This property is of type <code class="code-voice">UnicodeScalarView</code>, which is a collection of values of type <code class="code-voice">UnicodeScalar</code>.
</p><p class="para">
  Each <code class="code-voice">UnicodeScalar</code> has a <code class="code-voice">value</code> property that returns the scalar’s 21-bit value, represented within a <code class="code-voice">UInt32</code> value:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">scalar</span> <span class="kt">in</span> <span class="vc">dogString</span>.<span class="vc">unicodeScalars</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">print</span>(<span class="s">"</span>\(<span class="vc">scalar</span>.<span class="vc">value</span>)<span class="s"> "</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="vc">print</span>(<span class="s">"\n"</span>)</code></li>
          <li><code class="code-voice"><span class="c">// 68 111 103 8252 128054</span></code></li>
      </ul>



  </div>
</section><p class="para">
  The <code class="code-voice">value</code> properties for the first three <code class="code-voice">UnicodeScalar</code> values (<code class="code-voice">68</code>, <code class="code-voice">111</code>, <code class="code-voice">103</code>) once again represent the characters <code class="code-voice">D</code>, <code class="code-voice">o</code>, and <code class="code-voice">g</code>.
</p><p class="para">
  The fourth <code class="code-voice">codeUnit</code> value (<code class="code-voice">8252</code>) is again a decimal equivalent of the hexadecimal value <code class="code-voice">203C</code>, which represents the Unicode scalar <code class="code-voice">U+203C</code> for the <code class="code-voice">DOUBLE EXCLAMATION MARK</code> character.
</p><p class="para">
  The <code class="code-voice">value</code> property of the fifth and final <code class="code-voice">UnicodeScalar</code>, <code class="code-voice">128054</code>, is a decimal equivalent of the hexadecimal value <code class="code-voice">1F436</code>, which represents the Unicode scalar <code class="code-voice">U+1F436</code> for the <code class="code-voice">DOG FACE</code> character.
</p><p class="para">
  As an alternative to querying their <code class="code-voice">value</code> properties, each <code class="code-voice">UnicodeScalar</code> value can also be used to construct a new <code class="code-voice">String</code> value, such as with string interpolation:
</p><section class="code-listing">
  
  <span class="caption"></span>
  <div class="code-sample">

      <ul class="code-lines">
          <li><code class="code-voice"><span class="kt">for</span> <span class="vc">scalar</span> <span class="kt">in</span> <span class="vc">dogString</span>.<span class="vc">unicodeScalars</span> {</code></li>
          <li><code class="code-voice">    <span class="vc">println</span>(<span class="s">"</span>\(<span class="vc">scalar</span>)<span class="s"> "</span>)</code></li>
          <li><code class="code-voice">}</code></li>
          <li><code class="code-voice"><span class="c">// D</span></code></li>
          <li><code class="code-voice"><span class="c">// o</span></code></li>
          <li><code class="code-voice"><span class="c">// g</span></code></li>
          <li><code class="code-voice"><span class="c">// ‼</span></code></li>
          <li><code class="code-voice"><span class="c">// 🐶</span></code></li>
      </ul>



  </div>
</section>
  
</section>

</section>

  	
 	<section id="next_previous" class="">
    		<p class="previous-link"><a href="BasicOperators.html#//apple_ref/doc/uid/TP40014097-CH6-XID_109" data-id="//apple_ref/doc/uid/TP40014097-CH6-XID_109">Basic Operators</a></p>
  			<p class="next-link"><a href="CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-XID_168" data-id="//apple_ref/doc/uid/TP40014097-CH8-XID_168">Collection Types</a></p>
  <p class="copyright">Copyright © 2014 Apple Inc. All rights reserved. <a class="link" href="http://www.apple.com/legal/terms/site.html" target="_blank" rel="external">Terms of Use</a>   |  <a class="link" href="http://www.apple.com/privacy/" target="_blank" rel="external">Privacy Policy</a>  |  Updated: 2014-08-14
  </p>
  </section>
</article>